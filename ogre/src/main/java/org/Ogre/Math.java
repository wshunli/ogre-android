/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 4.0.0
 *
 * Do not make changes to this file unless you know what you are doing--modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

package org.Ogre;

public class Math {
  private transient long swigCPtr;
  protected transient boolean swigCMemOwn;

  protected Math(long cPtr, boolean cMemoryOwn) {
    swigCMemOwn = cMemoryOwn;
    swigCPtr = cPtr;
  }

  protected static long getCPtr(Math obj) {
    return (obj == null) ? 0 : obj.swigCPtr;
  }

  protected void finalize() {
    delete();
  }

  public synchronized void delete() {
    if (swigCPtr != 0) {
      if (swigCMemOwn) {
        swigCMemOwn = false;
        OgreJNI.delete_Math(swigCPtr);
      }
      swigCPtr = 0;
    }
  }

  static public class RandomValueProvider {
    private transient long swigCPtr;
    protected transient boolean swigCMemOwn;
  
    protected RandomValueProvider(long cPtr, boolean cMemoryOwn) {
      swigCMemOwn = cMemoryOwn;
      swigCPtr = cPtr;
    }
  
    protected static long getCPtr(RandomValueProvider obj) {
      return (obj == null) ? 0 : obj.swigCPtr;
    }
  
    protected void finalize() {
      delete();
    }
  
    public synchronized void delete() {
      if (swigCPtr != 0) {
        if (swigCMemOwn) {
          swigCMemOwn = false;
          OgreJNI.delete_Math_RandomValueProvider(swigCPtr);
        }
        swigCPtr = 0;
      }
    }
  
    public float getRandomUnit() {
      return OgreJNI.Math_RandomValueProvider_getRandomUnit(swigCPtr, this);
    }
  
  }

  public Math(long trigTableSize) {
    this(OgreJNI.new_Math__SWIG_0(trigTableSize), true);
  }

  public Math() {
    this(OgreJNI.new_Math__SWIG_1(), true);
  }

  public static int IAbs(int iValue) {
    return OgreJNI.Math_IAbs(iValue);
  }

  public static int ICeil(float fValue) {
    return OgreJNI.Math_ICeil(fValue);
  }

  public static int IFloor(float fValue) {
    return OgreJNI.Math_IFloor(fValue);
  }

  public static int ISign(int iValue) {
    return OgreJNI.Math_ISign(iValue);
  }

  public static float Abs(float fValue) {
    return OgreJNI.Math_Abs__SWIG_0(fValue);
  }

  public static Degree Abs(Degree dValue) {
    return new Degree(OgreJNI.Math_Abs__SWIG_1(Degree.getCPtr(dValue), dValue), true);
  }

  public static Radian Abs(Radian rValue) {
    return new Radian(OgreJNI.Math_Abs__SWIG_2(Radian.getCPtr(rValue), rValue), true);
  }

  public static Radian ACos(float fValue) {
    return new Radian(OgreJNI.Math_ACos(fValue), true);
  }

  public static Radian ASin(float fValue) {
    return new Radian(OgreJNI.Math_ASin(fValue), true);
  }

  public static Radian ATan(float fValue) {
    return new Radian(OgreJNI.Math_ATan(fValue), true);
  }

  public static Radian ATan2(float fY, float fX) {
    return new Radian(OgreJNI.Math_ATan2(fY, fX), true);
  }

  public static float Ceil(float fValue) {
    return OgreJNI.Math_Ceil(fValue);
  }

  public static boolean isNaN(float f) {
    return OgreJNI.Math_isNaN(f);
  }

  public static float Cos(Radian fValue, boolean useTables) {
    return OgreJNI.Math_Cos__SWIG_0(Radian.getCPtr(fValue), fValue, useTables);
  }

  public static float Cos(Radian fValue) {
    return OgreJNI.Math_Cos__SWIG_1(Radian.getCPtr(fValue), fValue);
  }

  public static float Cos(float fValue, boolean useTables) {
    return OgreJNI.Math_Cos__SWIG_2(fValue, useTables);
  }

  public static float Cos(float fValue) {
    return OgreJNI.Math_Cos__SWIG_3(fValue);
  }

  public static float Exp(float fValue) {
    return OgreJNI.Math_Exp(fValue);
  }

  public static float Floor(float fValue) {
    return OgreJNI.Math_Floor(fValue);
  }

  public static float Log(float fValue) {
    return OgreJNI.Math_Log(fValue);
  }

  public static float getLOG2() {
    return OgreJNI.Math_LOG2_get();
  }

  public static float Log2(float fValue) {
    return OgreJNI.Math_Log2(fValue);
  }

  public static float LogN(float base, float fValue) {
    return OgreJNI.Math_LogN(base, fValue);
  }

  public static float Pow(float fBase, float fExponent) {
    return OgreJNI.Math_Pow(fBase, fExponent);
  }

  public static float Sign(float fValue) {
    return OgreJNI.Math_Sign__SWIG_0(fValue);
  }

  public static Radian Sign(Radian rValue) {
    return new Radian(OgreJNI.Math_Sign__SWIG_1(Radian.getCPtr(rValue), rValue), true);
  }

  public static Degree Sign(Degree dValue) {
    return new Degree(OgreJNI.Math_Sign__SWIG_2(Degree.getCPtr(dValue), dValue), true);
  }

  public static float saturate(float t) {
    return OgreJNI.Math_saturate__SWIG_0(t);
  }

  public static double saturate(double t) {
    return OgreJNI.Math_saturate__SWIG_1(t);
  }

  public static float Sin(Radian fValue, boolean useTables) {
    return OgreJNI.Math_Sin__SWIG_0(Radian.getCPtr(fValue), fValue, useTables);
  }

  public static float Sin(Radian fValue) {
    return OgreJNI.Math_Sin__SWIG_1(Radian.getCPtr(fValue), fValue);
  }

  public static float Sin(float fValue, boolean useTables) {
    return OgreJNI.Math_Sin__SWIG_2(fValue, useTables);
  }

  public static float Sin(float fValue) {
    return OgreJNI.Math_Sin__SWIG_3(fValue);
  }

  public static float Sqr(float fValue) {
    return OgreJNI.Math_Sqr(fValue);
  }

  public static float Sqrt(float fValue) {
    return OgreJNI.Math_Sqrt__SWIG_0(fValue);
  }

  public static Radian Sqrt(Radian fValue) {
    return new Radian(OgreJNI.Math_Sqrt__SWIG_1(Radian.getCPtr(fValue), fValue), true);
  }

  public static Degree Sqrt(Degree fValue) {
    return new Degree(OgreJNI.Math_Sqrt__SWIG_2(Degree.getCPtr(fValue), fValue), true);
  }

  public static float InvSqrt(float fValue) {
    return OgreJNI.Math_InvSqrt(fValue);
  }

  public static float UnitRandom() {
    return OgreJNI.Math_UnitRandom();
  }

  public static float RangeRandom(float fLow, float fHigh) {
    return OgreJNI.Math_RangeRandom(fLow, fHigh);
  }

  public static float SymmetricRandom() {
    return OgreJNI.Math_SymmetricRandom();
  }

  public static void SetRandomValueProvider(Math.RandomValueProvider provider) {
    OgreJNI.Math_SetRandomValueProvider(Math.RandomValueProvider.getCPtr(provider), provider);
  }

  public static float Tan(Radian fValue, boolean useTables) {
    return OgreJNI.Math_Tan__SWIG_0(Radian.getCPtr(fValue), fValue, useTables);
  }

  public static float Tan(Radian fValue) {
    return OgreJNI.Math_Tan__SWIG_1(Radian.getCPtr(fValue), fValue);
  }

  public static float Tan(float fValue, boolean useTables) {
    return OgreJNI.Math_Tan__SWIG_2(fValue, useTables);
  }

  public static float Tan(float fValue) {
    return OgreJNI.Math_Tan__SWIG_3(fValue);
  }

  public static float DegreesToRadians(float degrees) {
    return OgreJNI.Math_DegreesToRadians(degrees);
  }

  public static float RadiansToDegrees(float radians) {
    return OgreJNI.Math_RadiansToDegrees(radians);
  }

  public static void setAngleUnit(Math.AngleUnit unit) {
    OgreJNI.Math_setAngleUnit(unit.swigValue());
  }

  public static Math.AngleUnit getAngleUnit() {
    return Math.AngleUnit.swigToEnum(OgreJNI.Math_getAngleUnit());
  }

  public static float AngleUnitsToRadians(float units) {
    return OgreJNI.Math_AngleUnitsToRadians(units);
  }

  public static float RadiansToAngleUnits(float radians) {
    return OgreJNI.Math_RadiansToAngleUnits(radians);
  }

  public static float AngleUnitsToDegrees(float units) {
    return OgreJNI.Math_AngleUnitsToDegrees(units);
  }

  public static float DegreesToAngleUnits(float degrees) {
    return OgreJNI.Math_DegreesToAngleUnits(degrees);
  }

  public static boolean pointInTri2D(Vector2 p, Vector2 a, Vector2 b, Vector2 c) {
    return OgreJNI.Math_pointInTri2D(Vector2.getCPtr(p), p, Vector2.getCPtr(a), a, Vector2.getCPtr(b), b, Vector2.getCPtr(c), c);
  }

  public static boolean pointInTri3D(Vector3 p, Vector3 a, Vector3 b, Vector3 c, Vector3 normal) {
    return OgreJNI.Math_pointInTri3D(Vector3.getCPtr(p), p, Vector3.getCPtr(a), a, Vector3.getCPtr(b), b, Vector3.getCPtr(c), c, Vector3.getCPtr(normal), normal);
  }

  public static SWIGTYPE_p_std__pairT_bool_float_t intersects(Ray ray, Plane plane) {
    return new SWIGTYPE_p_std__pairT_bool_float_t(OgreJNI.Math_intersects__SWIG_0(Ray.getCPtr(ray), ray, Plane.getCPtr(plane), plane), true);
  }

  public static SWIGTYPE_p_std__pairT_bool_float_t intersects(Ray ray, Sphere sphere, boolean discardInside) {
    return new SWIGTYPE_p_std__pairT_bool_float_t(OgreJNI.Math_intersects__SWIG_1(Ray.getCPtr(ray), ray, Sphere.getCPtr(sphere), sphere, discardInside), true);
  }

  public static SWIGTYPE_p_std__pairT_bool_float_t intersects(Ray ray, Sphere sphere) {
    return new SWIGTYPE_p_std__pairT_bool_float_t(OgreJNI.Math_intersects__SWIG_2(Ray.getCPtr(ray), ray, Sphere.getCPtr(sphere), sphere), true);
  }

  public static SWIGTYPE_p_std__pairT_bool_float_t intersects(Ray ray, AxisAlignedBox box) {
    return new SWIGTYPE_p_std__pairT_bool_float_t(OgreJNI.Math_intersects__SWIG_3(Ray.getCPtr(ray), ray, AxisAlignedBox.getCPtr(box), box), true);
  }

  public static boolean intersects(Ray ray, AxisAlignedBox box, SWIGTYPE_p_float d1, SWIGTYPE_p_float d2) {
    return OgreJNI.Math_intersects__SWIG_4(Ray.getCPtr(ray), ray, AxisAlignedBox.getCPtr(box), box, SWIGTYPE_p_float.getCPtr(d1), SWIGTYPE_p_float.getCPtr(d2));
  }

  public static SWIGTYPE_p_std__pairT_bool_float_t intersects(Ray ray, Vector3 a, Vector3 b, Vector3 c, Vector3 normal, boolean positiveSide, boolean negativeSide) {
    return new SWIGTYPE_p_std__pairT_bool_float_t(OgreJNI.Math_intersects__SWIG_5(Ray.getCPtr(ray), ray, Vector3.getCPtr(a), a, Vector3.getCPtr(b), b, Vector3.getCPtr(c), c, Vector3.getCPtr(normal), normal, positiveSide, negativeSide), true);
  }

  public static SWIGTYPE_p_std__pairT_bool_float_t intersects(Ray ray, Vector3 a, Vector3 b, Vector3 c, Vector3 normal, boolean positiveSide) {
    return new SWIGTYPE_p_std__pairT_bool_float_t(OgreJNI.Math_intersects__SWIG_6(Ray.getCPtr(ray), ray, Vector3.getCPtr(a), a, Vector3.getCPtr(b), b, Vector3.getCPtr(c), c, Vector3.getCPtr(normal), normal, positiveSide), true);
  }

  public static SWIGTYPE_p_std__pairT_bool_float_t intersects(Ray ray, Vector3 a, Vector3 b, Vector3 c, Vector3 normal) {
    return new SWIGTYPE_p_std__pairT_bool_float_t(OgreJNI.Math_intersects__SWIG_7(Ray.getCPtr(ray), ray, Vector3.getCPtr(a), a, Vector3.getCPtr(b), b, Vector3.getCPtr(c), c, Vector3.getCPtr(normal), normal), true);
  }

  public static SWIGTYPE_p_std__pairT_bool_float_t intersects(Ray ray, Vector3 a, Vector3 b, Vector3 c, boolean positiveSide, boolean negativeSide) {
    return new SWIGTYPE_p_std__pairT_bool_float_t(OgreJNI.Math_intersects__SWIG_8(Ray.getCPtr(ray), ray, Vector3.getCPtr(a), a, Vector3.getCPtr(b), b, Vector3.getCPtr(c), c, positiveSide, negativeSide), true);
  }

  public static SWIGTYPE_p_std__pairT_bool_float_t intersects(Ray ray, Vector3 a, Vector3 b, Vector3 c, boolean positiveSide) {
    return new SWIGTYPE_p_std__pairT_bool_float_t(OgreJNI.Math_intersects__SWIG_9(Ray.getCPtr(ray), ray, Vector3.getCPtr(a), a, Vector3.getCPtr(b), b, Vector3.getCPtr(c), c, positiveSide), true);
  }

  public static SWIGTYPE_p_std__pairT_bool_float_t intersects(Ray ray, Vector3 a, Vector3 b, Vector3 c) {
    return new SWIGTYPE_p_std__pairT_bool_float_t(OgreJNI.Math_intersects__SWIG_10(Ray.getCPtr(ray), ray, Vector3.getCPtr(a), a, Vector3.getCPtr(b), b, Vector3.getCPtr(c), c), true);
  }

  public static boolean intersects(Sphere sphere, AxisAlignedBox box) {
    return OgreJNI.Math_intersects__SWIG_11(Sphere.getCPtr(sphere), sphere, AxisAlignedBox.getCPtr(box), box);
  }

  public static boolean intersects(Plane plane, AxisAlignedBox box) {
    return OgreJNI.Math_intersects__SWIG_12(Plane.getCPtr(plane), plane, AxisAlignedBox.getCPtr(box), box);
  }

  public static SWIGTYPE_p_std__pairT_bool_float_t intersects(Ray ray, SWIGTYPE_p_Ogre__vectorT_Ogre__Plane_t__type planeList, boolean normalIsOutside) {
    return new SWIGTYPE_p_std__pairT_bool_float_t(OgreJNI.Math_intersects__SWIG_13(Ray.getCPtr(ray), ray, SWIGTYPE_p_Ogre__vectorT_Ogre__Plane_t__type.getCPtr(planeList), normalIsOutside), true);
  }

  public static SWIGTYPE_p_std__pairT_bool_float_t intersects(Ray ray, SWIGTYPE_p_Ogre__listT_Ogre__Plane_t__type planeList, boolean normalIsOutside) {
    return new SWIGTYPE_p_std__pairT_bool_float_t(OgreJNI.Math_intersects__SWIG_14(Ray.getCPtr(ray), ray, SWIGTYPE_p_Ogre__listT_Ogre__Plane_t__type.getCPtr(planeList), normalIsOutside), true);
  }

  public static boolean intersects(Sphere sphere, Plane plane) {
    return OgreJNI.Math_intersects__SWIG_15(Sphere.getCPtr(sphere), sphere, Plane.getCPtr(plane), plane);
  }

  public static boolean RealEqual(float a, float b, float tolerance) {
    return OgreJNI.Math_RealEqual__SWIG_0(a, b, tolerance);
  }

  public static boolean RealEqual(float a, float b) {
    return OgreJNI.Math_RealEqual__SWIG_1(a, b);
  }

  public static Vector3 calculateTangentSpaceVector(Vector3 position1, Vector3 position2, Vector3 position3, float u1, float v1, float u2, float v2, float u3, float v3) {
    return new Vector3(OgreJNI.Math_calculateTangentSpaceVector(Vector3.getCPtr(position1), position1, Vector3.getCPtr(position2), position2, Vector3.getCPtr(position3), position3, u1, v1, u2, v2, u3, v3), true);
  }

  public static Matrix4 buildReflectionMatrix(Plane p) {
    return new Matrix4(OgreJNI.Math_buildReflectionMatrix(Plane.getCPtr(p), p), true);
  }

  public static Vector4 calculateFaceNormal(Vector3 v1, Vector3 v2, Vector3 v3) {
    return new Vector4(OgreJNI.Math_calculateFaceNormal(Vector3.getCPtr(v1), v1, Vector3.getCPtr(v2), v2, Vector3.getCPtr(v3), v3), true);
  }

  public static Vector3 calculateBasicFaceNormal(Vector3 v1, Vector3 v2, Vector3 v3) {
    return new Vector3(OgreJNI.Math_calculateBasicFaceNormal(Vector3.getCPtr(v1), v1, Vector3.getCPtr(v2), v2, Vector3.getCPtr(v3), v3), true);
  }

  public static Vector4 calculateFaceNormalWithoutNormalize(Vector3 v1, Vector3 v2, Vector3 v3) {
    return new Vector4(OgreJNI.Math_calculateFaceNormalWithoutNormalize(Vector3.getCPtr(v1), v1, Vector3.getCPtr(v2), v2, Vector3.getCPtr(v3), v3), true);
  }

  public static Vector3 calculateBasicFaceNormalWithoutNormalize(Vector3 v1, Vector3 v2, Vector3 v3) {
    return new Vector3(OgreJNI.Math_calculateBasicFaceNormalWithoutNormalize(Vector3.getCPtr(v1), v1, Vector3.getCPtr(v2), v2, Vector3.getCPtr(v3), v3), true);
  }

  public static float gaussianDistribution(float x, float offset, float scale) {
    return OgreJNI.Math_gaussianDistribution__SWIG_0(x, offset, scale);
  }

  public static float gaussianDistribution(float x, float offset) {
    return OgreJNI.Math_gaussianDistribution__SWIG_1(x, offset);
  }

  public static float gaussianDistribution(float x) {
    return OgreJNI.Math_gaussianDistribution__SWIG_2(x);
  }

  public static Matrix4 makeViewMatrix(Vector3 position, Quaternion orientation, Matrix4 reflectMatrix) {
    return new Matrix4(OgreJNI.Math_makeViewMatrix__SWIG_0(Vector3.getCPtr(position), position, Quaternion.getCPtr(orientation), orientation, Matrix4.getCPtr(reflectMatrix), reflectMatrix), true);
  }

  public static Matrix4 makeViewMatrix(Vector3 position, Quaternion orientation) {
    return new Matrix4(OgreJNI.Math_makeViewMatrix__SWIG_1(Vector3.getCPtr(position), position, Quaternion.getCPtr(orientation), orientation), true);
  }

  public static float boundingRadiusFromAABB(AxisAlignedBox aabb) {
    return OgreJNI.Math_boundingRadiusFromAABB(AxisAlignedBox.getCPtr(aabb), aabb);
  }

  public static float boundingRadiusFromAABBCentered(AxisAlignedBox aabb) {
    return OgreJNI.Math_boundingRadiusFromAABBCentered(AxisAlignedBox.getCPtr(aabb), aabb);
  }

  public static float getPOS_INFINITY() {
    return OgreJNI.Math_POS_INFINITY_get();
  }

  public static float getNEG_INFINITY() {
    return OgreJNI.Math_NEG_INFINITY_get();
  }

  public static float getPI() {
    return OgreJNI.Math_PI_get();
  }

  public static float getTWO_PI() {
    return OgreJNI.Math_TWO_PI_get();
  }

  public static float getHALF_PI() {
    return OgreJNI.Math_HALF_PI_get();
  }

  public static float getFDeg2Rad() {
    return OgreJNI.Math_fDeg2Rad_get();
  }

  public static float getFRad2Deg() {
    return OgreJNI.Math_fRad2Deg_get();
  }

  public final static class AngleUnit {
    public final static Math.AngleUnit AU_DEGREE = new Math.AngleUnit("AU_DEGREE");
    public final static Math.AngleUnit AU_RADIAN = new Math.AngleUnit("AU_RADIAN");

    public final int swigValue() {
      return swigValue;
    }

    public String toString() {
      return swigName;
    }

    public static AngleUnit swigToEnum(int swigValue) {
      if (swigValue < swigValues.length && swigValue >= 0 && swigValues[swigValue].swigValue == swigValue)
        return swigValues[swigValue];
      for (int i = 0; i < swigValues.length; i++)
        if (swigValues[i].swigValue == swigValue)
          return swigValues[i];
      throw new IllegalArgumentException("No enum " + AngleUnit.class + " with value " + swigValue);
    }

    private AngleUnit(String swigName) {
      this.swigName = swigName;
      this.swigValue = swigNext++;
    }

    private AngleUnit(String swigName, int swigValue) {
      this.swigName = swigName;
      this.swigValue = swigValue;
      swigNext = swigValue+1;
    }

    private AngleUnit(String swigName, AngleUnit swigEnum) {
      this.swigName = swigName;
      this.swigValue = swigEnum.swigValue;
      swigNext = this.swigValue+1;
    }

    private static AngleUnit[] swigValues = { AU_DEGREE, AU_RADIAN };
    private static int swigNext = 0;
    private final int swigValue;
    private final String swigName;
  }

}
